
- beans:
    - name: orderState
      type: "#class:java.util.concurrent.ConcurrentHashMap"
- route:
    id: saga-orchestrator
    from:
      id: order-generator-timer
      uri: timer
      parameters:
        delay: "5000"
        period: 10000
        repeatCount: 3
        timerName: order-generator
      steps:
        - setHeader:
            id: set-order-id
            expression:
              groovy:
                expression: UUID.randomUUID().toString().substring(0,8)
            name: orderId
        - setHeader:
            id: set-customer-id
            expression:
              constant: CUST-001
            name: customerId
        - setHeader:
            id: set-amount
            expression:
              groovy:
                expression: Math.round(Math.random() * 1000 + 100)
            name: amount
        - setHeader:
            id: set-payment-failure-flag
            expression:
              groovy:
                expression: Math.random() < 0.3
            name: shouldFailPayment
        - script:
            id: store-order-context
            groovy:
              expression: >
                def appContext =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                appContext.put("currentOrderId", orderId)

                appContext.put("sagaContext_" + Thread.currentThread().id,
                orderId)

                return orderId
        - log:
            id: log-saga-start
            message: "Starting SAGA for Order: ${header.orderId}, Amount: ${header.amount}"
        - saga:
            id: saga-init
            compensation: direct:saga-compensate
            completion: direct:saga-complete
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
            propagation: REQUIRED
        - to:
            id: call-reserve-inventory
            uri: direct:reserve-inventory
        - to:
            id: call-process-payment
            uri: direct:process-payment
        - to:
            id: call-create-shipping
            uri: direct:create-shipping
        - to:
            id: call-send-confirmation
            uri: direct:send-confirmation
        - log:
            id: log-saga-success
            message: "SAGA completed successfully for Order: ${header.sagaOrderId}"
- route:
    id: reserve-inventory
    from:
      id: reserve-inventory-direct
      uri: direct:reserve-inventory
      steps:
        - saga:
            id: saga-inventory-compensation
            compensation: direct:release-inventory
        - log:
            id: log-inventory-start
            message: "Reserving inventory for Order: ${header.orderId}"
        - script:
            id: inventory-reservation-logic
            groovy:
              expression: >
                // Simulate inventory reservation

                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                orderState.put(orderId + '_inventory', 'RESERVED')


                // Simulate occasional inventory failure

                if (Math.random() < 0.1) {
                  throw new RuntimeException("Inventory not available")
                }


                request.headers['inventoryReserved'] = true

                "Inventory reserved for order: " + orderId
        - log:
            id: log-inventory-success
            message: "Inventory reserved for Order: ${header.orderId}"
- route:
    id: release-inventory
    from:
      id: release-inventory-direct
      uri: direct:release-inventory
      steps:
        - log:
            id: log-inventory-compensation
            message: "COMPENSATING: Releasing inventory for Order: ${header.orderId}"
        - script:
            id: inventory-release-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                orderState.put(orderId + '_inventory', 'RELEASED')

                "Inventory released for order: " + orderId
- route:
    id: process-payment
    from:
      id: process-payment-direct
      uri: direct:process-payment
      steps:
        - saga:
            id: saga-payment-compensation
            compensation: direct:refund-payment
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
        - log:
            id: log-payment-start
            message: "Processing payment for Order: ${header.orderId}, Amount:
              ${header.amount}"
        - doTry:
            id: try-payment-processing
            steps:
              - script:
                  id: payment-processing-logic
                  groovy:
                    expression: >
                      def orderState =
                      exchange.context.registry.lookupByName('orderState')

                      def orderId = request.headers['orderId']

                      def shouldFail = request.headers['shouldFailPayment']


                      if (shouldFail) {
                        throw new RuntimeException("Payment declined - insufficient funds")
                      } else {
                        orderState.put(orderId + '_payment', 'PROCESSED')
                        request.headers['paymentProcessed'] = true
                        "Payment processed for order: " + orderId
                      }
              - log:
                  id: log-payment-success
                  message: "Payment processed for Order: ${header.orderId}"
            doCatch:
              - steps:
                  - log:
                      id: log-payment-error
                      message: " Payment failed for Order: ${header.orderId} - ${exception.message}"
                  - throwException:
                      id: rethrow-payment-error
                      exceptionType: java.lang.RuntimeException
                      message: ${exception.message}
                exception:
                  - java.lang.RuntimeException
        - log:
            id: log-payment-success
            message: "Payment processed for Order: ${header.orderId}"
- route:
    id: refund-payment
    from:
      id: refund-payment-direct
      uri: direct:refund-payment
      steps:
        - log:
            id: log-payment-compensation
            message: "COMPENSATING: Refunding payment for Order: ${header.orderId}"
        - script:
            id: payment-refund-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                orderState.put(orderId + '_payment', 'REFUNDED')

                "Payment refunded for order: " + orderId
- route:
    id: create-shipping
    from:
      id: create-shipping-direct
      uri: direct:create-shipping
      steps:
        - saga:
            id: saga-shipping-compensation
            compensation: direct:cancel-shipping
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
        - log:
            id: log-shipping-start
            message: "Creating shipping for Order: ${header.orderId}"
        - script:
            id: shipping-creation-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']


                // Simulate rare shipping failure

                if (Math.random() < 0.05) {
                  orderState.put(orderId + 'shipping', 'FAILED')
                  throw new RuntimeException("Shipping service unavailable")
                }


                orderState.put(orderId + '_shipping', 'CREATED')

                request.headers['shippingCreated'] = true

                "Shipping created for order: " + orderId
        - log:
            id: log-shipping-success
            message: "Shipping created for Order: ${header.orderId}"
- route:
    id: cancel-shipping
    from:
      id: cancel-shipping-direct
      uri: direct:cancel-shipping
      steps:
        - log:
            id: log-shipping-compensation
            message: "COMPENSATING: Canceling shipping for Order: ${header.orderId}"
        - script:
            id: shipping-cancellation-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                orderState.put(orderId + '_shipping', 'CANCELLED')

                "Shipping cancelled for order: " + orderId
- route:
    id: send-confirmation
    from:
      id: send-confirmation-direct
      uri: direct:send-confirmation
      steps:
        - log:
            id: log-confirmation-start
            message: "Sending confirmation email for Order: ${header.orderId}"
        - script:
            id: confirmation-email-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']

                orderState.put(orderId + '_email', 'SENT')

                "Confirmation email sent for order: " + orderId
        - log:
            id: log-confirmation-success
            message: "Confirmation email sent for Order: ${header.orderId}"
- route:
    id: saga-completion
    from:
      id: saga-complete-direct
      uri: direct:saga-complete
      steps:
        - script:
            id: retrieve-order-context-completion
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = orderState.get("currentOrderId") ?: 
                             orderState.get("sagaContext_" + Thread.currentThread().id) ?:
                             exchange.getProperty("sagaOrderId")

                if (orderId) {
                  exchange.getIn().setBody(orderId)
                  return orderId
                } else {
                  println "ERROR: Could not retrieve orderId in completion"
                  return "UNKNOWN"
                }
        - log:
            id: log-saga-completion
            message: "SAGA COMPLETED: Order ${body} processed successfully!"
        - script:
            id: saga-completion-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = exchange.getIn().getBody(String.class)

                orderState.put(orderId + '_status', 'COMPLETED')


                println "=== FINAL ORDER STATE ==="

                if (orderId) {
                  exchange.getIn().setBody(orderId)
                  orderState.findAll { k, v -> k.startsWith(orderId) }.each { k, v ->
                    println "${k}: ${v}"
                  }
                } else {
                  println "OrderId is null! Cannot print order state."
                }

                println "========================="
- route:
    id: saga-compensation
    from:
      id: saga-compensate-direct
      uri: direct:saga-compensate
      steps:
        - script:
            id: retrieve-order-context-compensate
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = orderState.get("currentOrderId") ?: 
                             orderState.get("sagaContext_" + Thread.currentThread().id) ?:
                             exchange.getProperty("sagaOrderId")

                if (orderId) {
                  exchange.getIn().setBody(orderId)
                  return orderId
                } else {
                  println "ERROR: Could not retrieve orderId in completion"
                  return "UNKNOWN"
                }
        - log:
            id: log-saga-compensation
            message: "SAGA FAILED: Compensating Order ${header.orderId}"
        - script:
            id: saga-compensation-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = exchange.getIn().getBody(String.class)

                orderState.put(orderId + '_status', 'COMPENSATED')


                println "=== COMPENSATION COMPLETED ==="

                if (orderId) {
                  orderState.findAll { k, v -> k.startsWith(orderId) }.each { k, v ->
                    println "${k}: ${v}"
                  }
                } else {
                  println "OrderId is null! Cannot print order state."
                }

                println "==============================="
- route:
    id: health-check
    from:
      id: health-check-jetty
      uri: jetty:http://0.0.0.0:8001/health
      steps:
        - setHeader:
            id: set-orders-cors-origin
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - script:
            id: create-health-response
            groovy:
              expression: >
                import java.time.LocalDateTime

                import java.time.format.DateTimeFormatter


                def timestamp =
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd
                HH:mm:ss"))

                def healthResponse = [
                  status: "healthy",
                  service: "camel-saga-demo",
                  timestamp: timestamp
                ]


                exchange.getIn().setBody(healthResponse)

                return healthResponse
        - setHeader:
            id: set-health-content-type
            expression:
              constant: application/json
            name: Content-Type
        - marshal:
            json: {}
- route:
    id: order-status
    from:
      id: order-status-jetty
      uri: jetty:http://0.0.0.0:8001/orders
      steps:
        - setHeader:
            id: set-cors-origin
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - script:
            id: order-status-logic
            groovy:
              expression: >
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orders = [:]

                orderState.each { k, v ->
                  def parts = k.split('_')
                  if (parts.length == 2) {
                    def orderId = parts[0]
                    def field = parts[1]
                    if (!orders[orderId]) orders[orderId] = [:]
                    orders[orderId][field] = v
                  }
                }

                def result = [
                  orders: orders,
                  totalOrders: orders.size(),
                  timestamp: new Date().toString()
                ]


                // Set the result as the exchange body

                exchange.getIn().setBody(result)

                return result
        - setHeader:
            id: set-orders-content-type
            expression:
              constant: application/json
            name: Content-Type
        - marshal:
            json:
              library: Jackson
              unmarshalType: java.util.Map
