- beans:
    - name: orderState
      type: "#class:java.util.concurrent.ConcurrentHashMap"
    - name: inventoryState
      type: "#class:java.util.concurrent.ConcurrentHashMap"
    - name: sagaTracker
      type: "#class:java.util.concurrent.ConcurrentHashMap"

- route:
    id: inventory-initializer
    from:
      id: inventory-initializer-timer
      uri: timer:init
      parameters:
        repeatCount: 1
      steps:
        - script:
            id: initialize-inventory
            groovy:
              expression: |
                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')
                
                // Initialize inventory with real-world products

                inventoryState.put("ITM1_name", "iPhone 15 Pro")

                inventoryState.put("ITM1_stock", 100)

                inventoryState.put("ITM1_reserved", 0)


                inventoryState.put("ITM2_name", "MacBook Pro M3")

                inventoryState.put("ITM2_stock", 100)

                inventoryState.put("ITM2_reserved", 0)


                inventoryState.put("ITM3_name", "AirPods Pro")

                inventoryState.put("ITM3_stock", 100)

                inventoryState.put("ITM3_reserved", 0)


                println "=== INVENTORY INITIALIZED ==="

                inventoryState.findAll { k, v -> k.endsWith("_name") ||
                k.endsWith("_stock") }.each { k, v ->
                  println "${k}: ${v}"
                }

                println "============================="


                return "Inventory initialized"
- route:
    id: saga-orchestrator
    from:
      id: order-input
      uri: platform-http
      parameters:
        httpMethodRestrict: POST, GET, OPTIONS
        path: /orders
      steps:
        - setHeader:
            id: set-cors-headers
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - setHeader:
            id: set-cors-methods
            expression:
              constant: POST, GET, OPTIONS
            name: Access-Control-Allow-Methods
        - setHeader:
            id: set-cors-headers-allowed
            expression:
              constant: Content-Type
            name: Access-Control-Allow-Headers
        - choice:
            id: handle-cors-preflight
            otherwise:
              steps:
                - choice:
                    id: validate-http-method
                    otherwise:
                      steps:
                        - to:
                            id: call-status-route
                            uri: direct:order-status
                    when:
                      - steps:
                          - unmarshal:
                              id: unmarshal-json-order
                              json:
                                library: Jackson
                                unmarshalType: java.util.Map
                          - setHeader:
                              id: set-saga-id-header
                              name: sagaId
                              expression:
                                simple: ${random(1000,9999)}
                          - script:
                              id: validate-and-process-order
                              groovy:
                                expression: |
                                  
                                  def orderData = request.body

                                  def orderState =
                                  exchange.context.registry.lookupByName('orderState')

                                  def inventoryState =
                                  exchange.context.registry.lookupByName('inventoryState')


                                  // Validate order structure

                                  if (!orderData.orderId ||
                                  !orderData.orderItems || !orderData.address) {
                                    throw new RuntimeException("Invalid order format. Required fields: orderId, orderItems, address")
                                  }


                                  def orderId = orderData.orderId

                                  def orderItems = orderData.orderItems

                                  def address = orderData.address


                                  // Validate inventory availability

                                  def totalAmount = 0

                                  def reservationList = []


                                  for (item in orderItems) {
                                    def productId = item.productId
                                    def quantity = item.quantity
                                    
                                    def availableStock = inventoryState.get(productId + "_stock") ?: 0
                                    def reservedStock = inventoryState.get(productId + "_reserved") ?: 0
                                    def actualAvailable = availableStock - reservedStock
                                    
                                    if (quantity > actualAvailable) {
                                      def productName = inventoryState.get(productId + "_name") ?: productId
                                      throw new RuntimeException("Insufficient inventory for ${productName}. Requested: ${quantity}, Available: ${actualAvailable}")
                                    }
                                    
                                    // Calculate amount (simplified pricing)
                                    def itemPrice = productId == "ITM1" ? 999 : (productId == "ITM2" ? 1999 : 199)
                                    totalAmount += itemPrice * quantity
                                    
                                    reservationList.add([productId: productId, quantity: quantity])
                                  }


                                  // Store order context

                                  orderState.put(orderId + "_orderItems", orderItems)

                                  orderState.put(orderId + "_address", address)

                                  orderState.put(orderId + "_amount", totalAmount)

                                  orderState.put(orderId + "_reservationList", reservationList)

                                  orderState.put("currentOrderId", orderId)

                                  orderState.put("sagaContext_" + Thread.currentThread().id, orderId)

                                  orderState.put(orderId + "_timestamp", new Date().toString())

                                  orderState.put(orderId + "_threadId", Thread.currentThread().id)

                                  // Set headers for downstream processing

                                  request.headers['orderId'] = orderId

                                  request.headers['amount'] = totalAmount

                                  request.headers['shouldFailPayment'] = Math.random() < 0.3

                                  return orderId
                          - marshal:
                              id: marshal-order-id
                              json:
                                library: Jackson
                          - log:
                              id: log-saga-start
                              message: "Starting SAGA for Order: ${header.orderId}, Amount: ${header.amount}, Saga ID: ${header.sagaId}"
                          - doTry:
                              id: try-saga-processing
                              steps:
                                - to:
                                    id: call-process-order-saga
                                    uri: direct:process-order-saga
                                - script:
                                    id: create-success-response
                                    groovy:
                                      expression: |
                                        def response = [
                                          status: "success",
                                          message: "Order processed successfully",
                                          orderId: request.headers['orderId'],
                                          sagaId: request.headers['sagaId'],
                                          amount: request.headers['amount']
                                        ]

                                        exchange.getIn().setBody(response)

                                        return response
                                - marshal:
                                    id: marshal-success-response
                                    json:
                                      library: Jackson
                                - setHeader:
                                    id: set-success-content-type
                                    expression:
                                      constant: application/json
                                    name: Content-Type
                              doCatch:
                                - steps:
                                    - log:
                                        id: log-saga-failure
                                        message: "SAGA failed for Order: ${header.orderId}, Saga ID: ${header.sagaId} - ${exception.message}"
                                    - script:
                                        id: create-error-response
                                        groovy:
                                          expression: |
                                            def response = [
                                              status: "error",
                                              message: "Order failed and was compensated: ${exception.message}",
                                              orderId: request.headers['orderId'],
                                              sagaId: request.headers['sagaId'],
                                              error: exception.message
                                            ]

                                            exchange.getIn().setBody(response)

                                            return response
                                    - marshal:
                                        id: marshal-error-response
                                        json:
                                          library: Jackson
                                    - setHeader:
                                        id: set-error-content-type
                                        expression:
                                          constant: application/json
                                        name: Content-Type
                                    - setHeader:
                                        id: set-error-status
                                        expression:
                                          constant: "400"
                                        name: CamelHttpResponseCode
                                  exception:
                                    - java.lang.RuntimeException
                        expression:
                          simple: ${header.CamelHttpMethod} == 'POST'
            when:
              - steps:
                  - setBody:
                      id: set-cors-response
                      expression:
                        constant: ""
                  - stop: {}
                expression:
                  simple: ${header.CamelHttpMethod} == 'OPTIONS'
- route:
    id: process-order-saga
    from:
      id: process-order-saga-direct
      uri: direct:process-order-saga
      steps:
        - saga:
            id: saga-init
            compensation: direct:saga-compensate
            completion: direct:saga-complete
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
              - expression:
                  simple: ${date:now:yyyy-MM-dd'T'HH:mm:ss}
                key: startedAt
            propagation: REQUIRED
        - script:
            id: saga-tracking-script
            groovy:
              expression: |
                def lraId = exchange.in.headers['Long-Running-Action']
                def orderId = exchange.in.headers['orderId']
                def sagaId = exchange.in.headers['sagaId']
                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderData = [
                  orderId: orderId,
                  sagaId: sagaId,
                  lraId: lraId,
                  status: 'STARTED',
                  steps: [],
                  startTime: new Date().toString()
                ]

                sagaTracker.put(lraId, orderData)
                println "TRACKING: Stored order ${orderId} with LRA ${lraId} and Saga ${sagaId}"
        - to:
            id: call-reserve-inventory
            uri: direct:reserve-inventory
        - to:
            id: call-process-payment
            uri: direct:process-payment
        - to:
            id: call-create-shipping
            uri: direct:create-shipping
        - to:
            id: call-send-confirmation
            uri: direct:send-confirmation
        - log:
            id: log-saga-success
            message: "SAGA completed successfully for Order: ${header.orderId}, Saga ID: ${header.sagaId}"
- route:
    id: reserve-inventory
    from:
      id: reserve-inventory-direct
      uri: direct:reserve-inventory
      steps:
        - saga:
            id: saga-inventory-compensation
            compensation: direct:release-inventory
        - log:
            id: log-inventory-start
            message: "Reserving inventory for Order: ${header.orderId}"
        - script:
            id: inventory-tracking-script
            groovy:
              expression: |
                def lraId = exchange.in.headers['Long-Running-Action']
                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')
                def orderData = sagaTracker.get(lraId)

                if (orderData) {
                  orderData.currentStep = 'INVENTORY'
                  orderData.steps.add('INVENTORY_STARTED')
                  sagaTracker.put(lraId, orderData)
                }
        - script:
            id: inventory-reservation-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = request.headers['orderId']
                def lraId = exchange.in.headers['Long-Running-Action']


                def reservationList = orderState.get(orderId +
                "_reservationList")

                def reservedItems = []


                for (reservation in reservationList) {
                  def productId = reservation.productId
                  def quantity = reservation.quantity
                  def productName = inventoryState.get(productId + "_name")
                  
                  def currentStock = inventoryState.get(productId + "_stock")
                  def currentReserved = inventoryState.get(productId + "_reserved") ?: 0
                  def availableStock = currentStock - currentReserved
                  
                  if (quantity > availableStock) {
                    def orderData = sagaTracker.get(lraId)
                    if (orderData) {
                      orderData.failureReason = "Insufficient inventory for ${productName}. Available: ${availableStock}, Requested: ${quantity}"
                      orderData.steps.add('INVENTORY_FAILED')
                      sagaTracker.put(lraId, orderData)
                    }
                    throw new RuntimeException("Insufficient inventory for ${productName}. Available: ${availableStock}, Requested: ${quantity}")
                  }
                  
                  // Reserve the inventory
                  inventoryState.put(productId + "_reserved", currentReserved + quantity)
                  reservedItems.add([productId: productId, productName: productName, quantity: quantity])
                  
                  println "Reserved ${quantity} units of ${productName} (${productId})"
                }


                orderState.put(orderId + '_inventory', 'RESERVED')

                orderState.put(orderId + '_reservedItems', reservedItems)

                request.headers['inventoryReserved'] = true

                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  orderData.steps.add('INVENTORY_SUCCESS')
                  sagaTracker.put(lraId, orderData)
                }


                // Display current inventory status

                println "=== INVENTORY STATUS AFTER RESERVATION ==="

                ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                  def name = inventoryState.get(productId + "_name")
                  def stock = inventoryState.get(productId + "_stock")
                  def reserved = inventoryState.get(productId + "_reserved")
                  def available = stock - reserved
                  println "${name} (${productId}): Total=${stock}, Reserved=${reserved}, Available=${available}"
                }

                println "============================================="


                return "Inventory reserved for order: " + orderId
        - log:
            id: log-inventory-success
            message: "Inventory reserved for Order: ${header.orderId}"
- route:
    id: release-inventory
    from:
      id: release-inventory-direct
      uri: direct:release-inventory
      steps:
        - log:
            id: log-inventory-compensation
            message: "COMPENSATING: Releasing inventory for Order: ${header.orderId}"
        - script:
            id: inventory-release-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = request.headers['orderId']
                def lraId = exchange.in.headers['Long-Running-Action']


                def reservedItems = orderState.get(orderId + '_reservedItems')


                if (reservedItems) {
                  for (item in reservedItems) {
                    def productId = item.productId
                    def quantity = item.quantity
                    def productName = item.productName
                    
                    def currentReserved = inventoryState.get(productId + "_reserved") ?: 0
                    def newReserved = Math.max(0, currentReserved - quantity)
                    inventoryState.put(productId + "_reserved", newReserved)
                    
                    println "Released ${quantity} units of ${productName} (${productId})"
                  }
                }

                orderState.put(orderId + '_inventory', 'RELEASED')
                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  if (request.headers['inventoryReserved'] == true) {
                    println "COMPENSATION-INVENTORY: Released inventory for order ${orderId}"
                    orderData.steps.add('COMPENSATION_INVENTORY_SUCCESS')
                  } else {
                    println "COMPENSATION-INVENTORY: No inventory to release for order ${orderId}"
                    orderData.steps.add('COMPENSATION_INVENTORY_SKIPPED')
                  }
                  sagaTracker.put(lraId, orderData)
                }


                // Display current inventory status

                println "=== INVENTORY STATUS AFTER RELEASE ==="

                ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                  def name = inventoryState.get(productId + "_name")
                  def stock = inventoryState.get(productId + "_stock")
                  def reserved = inventoryState.get(productId + "_reserved")
                  def available = stock - reserved
                  println "${name} (${productId}): Total=${stock}, Reserved=${reserved}, Available=${available}"
                }

                println "======================================="


                return "Inventory released for order: " + orderId
- route:
    id: process-payment
    from:
      id: process-payment-direct
      uri: direct:process-payment
      steps:
        - saga:
            id: saga-payment-compensation
            compensation: direct:refund-payment
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
        - log:
            id: log-payment-start
            message: "Processing payment for Order: ${header.orderId}, Amount:
              ${header.amount}"
        - script:
            id: payment-tracking-script
            groovy:
              expression: |
                def lraId = exchange.in.headers['Long-Running-Action']
                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')
                def orderData = sagaTracker.get(lraId)

                if (orderData) {
                  orderData.currentStep = 'PAYMENT'
                  orderData.steps.add('PAYMENT_STARTED')
                  sagaTracker.put(lraId, orderData)
                }
        - doTry:
            id: try-payment-processing
            steps:
              - script:
                  id: payment-processing-logic
                  groovy:
                    expression: |
                      def orderState =
                      exchange.context.registry.lookupByName('orderState')

                      def inventoryState =
                      exchange.context.registry.lookupByName('inventoryState')

                      def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                      def orderId = request.headers['orderId']
                      def lraId = exchange.in.headers['Long-Running-Action']

                      def shouldFail = request.headers['shouldFailPayment']


                      if (shouldFail) {
                        def orderData = sagaTracker.get(lraId)
                        if (orderData) {
                          orderData.failureReason = "Payment declined - insufficient funds"
                          orderData.steps.add('PAYMENT_FAILED')
                          sagaTracker.put(lraId, orderData)
                        }
                        throw new RuntimeException("Payment declined - insufficient funds")
                      } else {
                        // Payment successful - convert reserved inventory to sold
                        def reservedItems = orderState.get(orderId + '_reservedItems')
                        
                        if (reservedItems) {
                          for (item in reservedItems) {
                            def productId = item.productId
                            def quantity = item.quantity
                            def productName = item.productName
                            
                            def currentStock = inventoryState.get(productId + "_stock")
                            def currentReserved = inventoryState.get(productId + "_reserved")
                            
                            // Reduce actual stock and reserved stock
                            inventoryState.put(productId + "_stock", currentStock - quantity)
                            inventoryState.put(productId + "_reserved", currentReserved - quantity)
                            
                            println "Sold ${quantity} units of ${productName} (${productId})"
                          }
                        }
                        
                        orderState.put(orderId + '_payment', 'PROCESSED')
                        request.headers['paymentProcessed'] = true
                        
                        // Update saga tracking
                        def orderData = sagaTracker.get(lraId)
                        if (orderData) {
                          orderData.steps.add('PAYMENT_SUCCESS')
                          sagaTracker.put(lraId, orderData)
                        }
                        
                        // Display current inventory status after sale
                        println "=== INVENTORY STATUS AFTER PAYMENT ==="
                        ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                          def name = inventoryState.get(productId + "_name")
                          def stock = inventoryState.get(productId + "_stock")
                          def reserved = inventoryState.get(productId + "_reserved")
                          def available = stock - reserved
                          println "${name} (${productId}): Total=${stock}, Reserved=${reserved}, Available=${available}"
                        }
                        println "=========================================="
                        
                        return "Payment processed for order: " + orderId
                      }
              - log:
                  id: log-payment-success
                  message: "Payment processed for Order: ${header.orderId}"
            doCatch:
              - steps:
                  - log:
                      id: log-payment-error
                      message: "Payment failed for Order: ${header.orderId} - ${exception.message}"
                  - throwException:
                      id: rethrow-payment-error
                      exceptionType: java.lang.RuntimeException
                      message: ${exception.message}
                exception:
                  - java.lang.RuntimeException
- route:
    id: refund-payment
    from:
      id: refund-payment-direct
      uri: direct:refund-payment
      steps:
        - log:
            id: log-payment-compensation
            message: "COMPENSATING: Refunding payment for Order: ${header.orderId}"
        - script:
            id: payment-refund-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = request.headers['orderId']
                def lraId = exchange.in.headers['Long-Running-Action']


                orderState.put(orderId + '_payment', 'REFUNDED')

                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  if (request.headers['paymentProcessed'] == true) {
                    println "COMPENSATION-PAYMENT: Refunded payment for order ${orderId}"
                    orderData.steps.add('COMPENSATION_PAYMENT_SUCCESS')
                  } else {
                    println "COMPENSATION-PAYMENT: No payment to refund for order ${orderId}"
                    orderData.steps.add('COMPENSATION_PAYMENT_SKIPPED')
                  }
                  sagaTracker.put(lraId, orderData)
                }


                return "Payment refunded for order: " + orderId
- route:
    id: create-shipping
    from:
      id: create-shipping-direct
      uri: direct:create-shipping
      steps:
        - saga:
            id: saga-shipping-compensation
            compensation: direct:cancel-shipping
            option:
              - expression:
                  simple: ${header.orderId}
                key: orderId
        - log:
            id: log-shipping-start
            message: "Creating shipping for Order: ${header.orderId}"
        - script:
            id: shipping-tracking-script
            groovy:
              expression: |
                def lraId = exchange.in.headers['Long-Running-Action']
                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')
                def orderData = sagaTracker.get(lraId)

                if (orderData) {
                  orderData.currentStep = 'SHIPPING'
                  orderData.steps.add('SHIPPING_STARTED')
                  sagaTracker.put(lraId, orderData)
                }
        - script:
            id: shipping-creation-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = request.headers['orderId']
                def lraId = exchange.in.headers['Long-Running-Action']


                // Simulate rare shipping failure

                if (Math.random() < 0.05) {
                  def orderData = sagaTracker.get(lraId)
                  if (orderData) {
                    orderData.failureReason = "Shipping service unavailable"
                    orderData.steps.add('SHIPPING_FAILED')
                    sagaTracker.put(lraId, orderData)
                  }
                  orderState.put(orderId + '_shipping', 'FAILED')
                  throw new RuntimeException("Shipping service unavailable")
                }


                def address = orderState.get(orderId + "_address")

                def shippingAddress = "${address.line1}, ${address.city}, ${address.state}, ${address.country} - ${address.pincode}"


                orderState.put(orderId + '_shipping', 'CREATED')

                orderState.put(orderId + '_shippingAddress', shippingAddress)

                request.headers['shippingCreated'] = true

                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  orderData.steps.add('SHIPPING_SUCCESS')
                  sagaTracker.put(lraId, orderData)
                }


                return "Shipping created for order: " + orderId + " to " + shippingAddress
        - log:
            id: log-shipping-success
            message: "Shipping created for Order: ${header.orderId}"
- route:
    id: cancel-shipping
    from:
      id: cancel-shipping-direct
      uri: direct:cancel-shipping
      steps:
        - log:
            id: log-shipping-compensation
            message: "COMPENSATING: Canceling shipping for Order: ${header.orderId}"
        - script:
            id: shipping-cancellation-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = request.headers['orderId']
                def lraId = exchange.in.headers['Long-Running-Action']


                orderState.put(orderId + '_shipping', 'CANCELLED')
                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  if (request.headers['shippingCreated'] == true) {
                    println "COMPENSATION-SHIPPING: Cancelled shipment for order ${orderId}"
                    orderData.steps.add('COMPENSATION_SHIPPING_SUCCESS')
                  } else {
                    println "COMPENSATION-SHIPPING: No shipment to cancel for order ${orderId}"
                    orderData.steps.add('COMPENSATION_SHIPPING_SKIPPED')
                  }
                  
                  // Mark compensation as completed
                  orderData.status = 'COMPENSATED'
                  orderData.compensationEndTime = new Date().toString()
                  sagaTracker.put(lraId, orderData)
                }


                return "Shipping cancelled for order: " + orderId
- route:
    id: send-confirmation
    from:
      id: send-confirmation-direct
      uri: direct:send-confirmation
      steps:
        - log:
            id: log-confirmation-start
            message: "Sending confirmation email for Order: ${header.orderId}"
        - script:
            id: confirmation-email-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = request.headers['orderId']


                def orderItems = orderState.get(orderId + "_orderItems")

                def address = orderState.get(orderId + "_address")

                def amount = orderState.get(orderId + "_amount")


                def emailContent = "Order Confirmation for ${orderId}\n"

                emailContent += "Items ordered:\n"

                orderItems.each { item -> emailContent += "- ${item.productId}: ${item.quantity} units\n" }

                emailContent += "Total Amount: \$${amount}\n"

                emailContent += "Shipping Address: ${address.line1}, ${address.city}, ${address.state}, ${address.country} - ${address.pincode}"

                orderState.put(orderId + '_email', 'SENT')

                orderState.put(orderId + '_emailContent', emailContent)


                return "Confirmation email sent for order: " + orderId
        - log:
            id: log-confirmation-success
            message: "Confirmation email sent for Order: ${header.orderId}"
- route:
    id: saga-completion
    from:
      id: saga-complete-direct
      uri: direct:saga-complete
      steps:
        - script:
            id: retrieve-order-context-completion
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = orderState.get("currentOrderId") ?: 
                             orderState.get("sagaContext_" + Thread.currentThread().id) ?:
                             exchange.getProperty("sagaOrderId")

                if (orderId) {
                  exchange.getIn().setBody(orderId)
                  return orderId
                } else {
                  println "ERROR: Could not retrieve orderId in completion"
                  return "UNKNOWN"
                }
        - log:
            id: log-saga-completion
            message: "SAGA COMPLETED: Order ${body} processed successfully! LRA-ID = ${header.Long-Running-Action}"
        - script:
            id: saga-completion-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = exchange.getIn().getBody(String.class)
                def lraId = exchange.in.headers['Long-Running-Action']


                orderState.put(orderId + '_status', 'COMPLETED')

                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  println "SUCCESS: Order ${orderData.orderId} completed successfully (Saga: ${orderData.sagaId})"
                  
                  // Update tracking data
                  orderData.status = 'COMPLETED'
                  orderData.endTime = new Date().toString()
                  orderData.steps.add('SAGA_COMPLETED')
                  sagaTracker.put(lraId, orderData)
                } else {
                  println "COMPLETION: No order data found for LRA ${lraId}"
                }


                println "=== FINAL ORDER STATE ==="

                if (orderId) {
                  def orderItems = orderState.get(orderId + "_orderItems")
                  def address = orderState.get(orderId + "_address")
                  def amount = orderState.get(orderId + "_amount")
                  
                  println "Order ID: ${orderId}"
                  println "Amount: \$${amount}"
                  println "Items:"
                  orderItems?.each { item ->
                    def productName = inventoryState.get(item.productId + "_name")
                    println "  - ${productName} (${item.productId}): ${item.quantity} units"
                  }
                  println "Shipping Address: ${address.line1}, ${address.city}, ${address.state}, ${address.country} - ${address.pincode}"
                  
                  orderState.findAll { k, v -> k.startsWith(orderId) && !k.contains("_orderItems") && !k.contains("_address") && !k.contains("_reservedItems") }.each { k, v ->
                    println "${k}: ${v}"
                  }
                } else {
                  println "OrderId is null! Cannot print order state."
                }

                println "========================="


                // Display final inventory status

                println "=== FINAL INVENTORY STATUS ==="

                ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                  def name = inventoryState.get(productId + "_name")
                  def stock = inventoryState.get(productId + "_stock")
                  def reserved = inventoryState.get(productId + "_reserved")
                  def available = stock - reserved
                  println "${name} (${productId}): Total=${stock}, Reserved=${reserved}, Available=${available}"
                }

                println "==============================="
- route:
    id: saga-compensation
    from:
      id: saga-compensate-direct
      uri: direct:saga-compensate
      steps:
        - script:
            id: retrieve-order-context-compensate
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def orderId = orderState.get("currentOrderId") ?: 
                             orderState.get("sagaContext_" + Thread.currentThread().id) ?:
                             exchange.getProperty("sagaOrderId")

                if (orderId) {
                  exchange.getIn().setBody(orderId)
                  return orderId
                } else {
                  println "ERROR: Could not retrieve orderId in compensation"
                  return "UNKNOWN"
                }
        - log:
            id: log-saga-compensation
            message: "SAGA FAILED: Compensating Order ${body} - LRA-ID = ${header.Long-Running-Action}"
        - script:
            id: saga-compensation-logic
            groovy:
              expression: |
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')

                def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')

                def orderId = exchange.getIn().getBody(String.class)
                def lraId = exchange.in.headers['Long-Running-Action']


                orderState.put(orderId + '_status', 'COMPENSATED')

                
                // Update saga tracking
                def orderData = sagaTracker.get(lraId)
                if (orderData) {
                  println "COMPENSATION: Order ${orderData.orderId} failed and needs rollback (Saga: ${orderData.sagaId})"
                  println "COMPENSATION: Failed at step ${orderData.currentStep} - Reason: ${orderData.failureReason}"
                  
                  // Update tracking data
                  orderData.status = 'COMPENSATING'
                  orderData.compensationStartTime = new Date().toString()
                  orderData.steps.add('SAGA_COMPENSATION_STARTED')
                  sagaTracker.put(lraId, orderData)
                } else {
                  println "COMPENSATION: No order data found for LRA ${lraId}"
                }


                println "=== COMPENSATION COMPLETED ==="

                if (orderId) {
                  def orderItems = orderState.get(orderId + "_orderItems")
                  def address = orderState.get(orderId + "_address")
                  def amount = orderState.get(orderId + "_amount")
                  
                  println "Order ID: ${orderId}"
                  println "Amount: \$${amount}"
                  println "Items:"
                  orderItems?.each { item ->
                    def productName = inventoryState.get(item.productId + "_name")
                    println "  - ${productName} (${item.productId}): ${item.quantity} units"
                  }
                  println "Shipping Address: ${address.line1}, ${address.city}, ${address.state}, ${address.country} - ${address.pincode}"
                  
                  orderState.findAll { k, v -> k.startsWith(orderId) && !k.contains("_orderItems") && !k.contains("_address") && !k.contains("_reservedItems") }.each { k, v ->
                    println "${k}: ${v}"
                  }
                } else {
                  println "OrderId is null! Cannot print order state."
                }

                println "==============================="


                // Display final inventory status after compensation

                println "=== INVENTORY STATUS AFTER COMPENSATION ==="

                ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                  def name = inventoryState.get(productId + "_name")
                  def stock = inventoryState.get(productId + "_stock")
                  def reserved = inventoryState.get(productId + "_reserved")
                  def available = stock - reserved
                  println "${name} (${productId}): Total=${stock}, Reserved=${reserved}, Available=${available}"
                }

                println "============================================"
- route:
    id: saga-tracker
    from:
      id: saga-tracker-jetty
      uri: platform-http:/saga-tracker
      steps:
        - setHeader:
            id: set-saga-cors-origin
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - setHeader:
            id: set-saga-cors-methods
            expression:
              constant: GET, OPTIONS
            name: Access-Control-Allow-Methods
        - choice:
            id: handle-saga-cors-preflight
            otherwise:
              steps:
                - script:
                    id: saga-tracker-logic
                    groovy:
                      expression: |
                        def sagaTracker = exchange.context.registry.lookupByName('sagaTracker')
                        def result = [:]

                        if (sagaTracker.isEmpty()) {
                          result.message = "No active or completed sagas"
                          result.count = 0
                          result.sagas = [:]
                        } else {
                          result.message = "Saga tracking status"
                          result.count = sagaTracker.size()
                          result.sagas = [:]
                          
                          sagaTracker.each { lraId, orderData ->
                            result.sagas[lraId] = orderData
                          }
                        }

                        exchange.getIn().setBody(result)
                - marshal:
                    id: marshal-saga-tracker
                    json:
                      library: Jackson
                - setHeader:
                    id: set-saga-content-type
                    expression:
                      constant: application/json
                    name: Content-Type
            when:
              - steps:
                  - setBody:
                      id: set-saga-cors-response
                      expression:
                        constant: ""
                  - stop: {}
                expression:
                  simple: ${header.CamelHttpMethod} == 'OPTIONS'
- route:
    id: inventory-status
    from:
      id: inventory-status-jetty
      uri: platform-http:/inventory
      steps:
        - setHeader:
            id: set-inventory-cors-origin
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - setHeader:
            id: set-inventory-cors-methods
            expression:
              constant: GET, OPTIONS
            name: Access-Control-Allow-Methods
        - choice:
            id: handle-inventory-cors-preflight
            otherwise:
              steps:
                - script:
                    id: inventory-status-logic
                    groovy:
                      expression: |
                        
                        def inventoryState =
                        exchange.context.registry.lookupByName('inventoryState')

                        def inventory = [:]


                        ['ITM1', 'ITM2', 'ITM3'].each { productId ->
                          def name = inventoryState.get(productId + "_name")
                          def stock = inventoryState.get(productId + "_stock") ?: 0
                          def reserved = inventoryState.get(productId + "_reserved") ?: 0
                          def available = stock - reserved
                          
                          inventory[productId] = [
                            name: name,
                            totalStock: stock,
                            reserved: reserved,
                            available: available
                          ]
                        }


                        def result = [
                          inventory: inventory,
                          timestamp: new Date().toString()
                        ]


                        exchange.getIn().setBody(result)

                        //return result
                - marshal:
                    id: marshal-inventory-status
                    json:
                      library: Jackson
                - setHeader:
                    id: set-inventory-content-type
                    expression:
                      constant: application/json
                    name: Content-Type
            when:
              - steps:
                  - setBody:
                      id: set-inventory-cors-response
                      expression:
                        constant: ""
                  - stop: {}
                expression:
                  simple: ${header.CamelHttpMethod} == 'OPTIONS'
- route:
    id: health-check
    from:
      id: health-check-jetty
      uri: platform-http:/health
      steps:
        - setHeader:
            id: set-health-cors-origin
            expression:
              constant: "*"
            name: Access-Control-Allow-Origin
        - script:
            id: create-health-response
            groovy:
              expression: |
                import java.time.LocalDateTime

                import java.time.format.DateTimeFormatter
                                
                def timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))

                def healthResponse = [
                  status: "healthy",
                  service: "camel-saga-demo-enhanced-with-lra",
                  timestamp: timestamp,
                  endpoints: [
                    "POST /orders - Submit new order",
                    "GET /inventory - Check inventory status", 
                    "GET /orders - View order status",
                    "GET /saga-tracker - View saga tracking status",
                    "GET /health - Health check"
                  ]
                ]


                exchange.getIn().setBody(healthResponse)
        - marshal:
            id: marshal-health-response
            json:
              library: Jackson
        - setHeader:
            id: set-health-content-type
            expression:
              constant: application/json
            name: Content-Type
- route:
    id: order-status-route
    from:
      id: order-status
      uri: direct:order-status
      steps:
        - script:
            id: order-status-logic
            groovy:
              expression: |
                
                def orderState =
                exchange.context.registry.lookupByName('orderState')

                def inventoryState =
                exchange.context.registry.lookupByName('inventoryState')

                def orders = [:]


                // Debug: Print all keys in orderState

                println "=== ALL ORDER STATE KEYS ==="

                def orderKeys = []

                def systemKeys = []

                orderState.each { k, v ->
                  if (k.contains('_') && !k.startsWith('currentOrderId') && !k.startsWith('sagaContext_')) {
                    orderKeys.add(k)
                    println "Order Key: ${k}"
                  } else {
                    systemKeys.add(k)
                    println "System Key: ${k}"
                  }
                }

                println "Total Order Keys: ${orderKeys.size()}"

                println "Total System Keys: ${systemKeys.size()}"

                println "==============================="


                // Group order data by orderId

                orderState.each { k, v ->
                  // Skip system keys but include all order-related keys
                  if (k.contains('_') && !k.startsWith('currentOrderId') && !k.startsWith('sagaContext_')) {
                    def parts = k.split('_', 2)
                    if (parts.length == 2) {
                      def orderId = parts[0]
                      def field = parts[1]
                      
                      // Initialize order object if it doesn't exist
                      if (!orders[orderId]) {
                        orders[orderId] = [orderId: orderId]
                      }
                      
                      // Store all fields
                      orders[orderId][field] = v
                    }
                  }
                }


                // Debug: Print grouped orders

                println "=== GROUPED ORDERS ==="

                orders.each { orderId, orderData ->
                  println "Order ID: ${orderId}"
                  orderData.each { field, value ->
                    println "  ${field}: ${value}"
                  }
                }

                println "======================"


                // Enhance orders with product names

                orders.each { orderId, orderData ->
                  if (orderData.orderItems) {
                    orderData.orderItems.each { item ->
                      item.productName = inventoryState.get(item.productId + "_name")
                    }
                  }
                }


                // Convert to list and sort by orderId (descending for newest first)

                def ordersList = orders.values().toList()

                ordersList.sort { a, b -> 
                  if (a.timestamp && b.timestamp) {
                    return b.timestamp <=> a.timestamp
                  }
                  return b.orderId <=> a.orderId
                }


                def result = [
                  orders: ordersList,
                  totalOrders: ordersList.size(),
                  timestamp: new Date().toString(),
                  debug: [
                    totalKeysInState: orderState.size(),
                    orderKeysFound: orders.size()
                  ]
                ]


                println "=== FINAL RESULT ==="

                println "Total orders found: ${ordersList.size()}"

                println "===================="


                exchange.getIn().setBody(result)
        - marshal:
            id: marshal-order-status
            json:
              library: Jackson
        - setHeader:
            id: set-orders-content-type
            expression:
              constant: application/json
            name: Content-Type
