# ==========================================
# HEXAGONAL ARCHITECTURE LAYERS:
# 1. Domain Core (Business Logic) - Groovy scripts
# 2. Application Services - Camel routes orchestration
# 3. Adapters (Infrastructure) - Switchable via properties
# ==========================================

- route:
    id: "inbound-http-adapter"
    description: "Primary Adapter - HTTP REST API (Driving Adapter)"
    from:
      uri: "jetty:http://0.0.0.0:8080/api/customers"
      parameters:
        httpMethodRestrict: "GET,POST,PUT,DELETE"
      steps:
        # Extract HTTP method and setup correlation
        - setHeader:
            name: "httpMethod"
            expression:
              simple: "${header.CamelHttpMethod}"
        - setHeader:
            name: "correlationId"
            expression:
              simple: "${date:now:yyyyMMdd-HHmmss-SSS}"
        
        # Log incoming request (Cross-cutting concern)
        - script:
            groovy: |
              def method = request.headers['httpMethod']
              def body = request.body
              def correlationId = request.headers['correlationId']
              
              log.info("üîµ INBOUND REQUEST - Method: ${method}, CorrelationId: ${correlationId}")
              log.info("Request Body: ${body}")
              
              // Add request timestamp for metrics
              request.headers['requestTimestamp'] = System.currentTimeMillis()
        
        # Route to Application Service (Core Orchestration)
        - to: "direct:customer-application-service"
        
        # Format response for HTTP
        - script:
            groovy: |
              def response = request.body
              def correlationId = request.headers['correlationId']
              
              log.info("üîµ OUTBOUND RESPONSE - CorrelationId: ${correlationId}")
              log.info("Response: ${response}")
              
              // Calculate processing time
              def startTime = request.headers['requestTimestamp'] as Long
              def processingTime = System.currentTimeMillis() - startTime
              log.info("Processing time: ${processingTime}ms")
              
              // Set HTTP response headers
              request.headers['Content-Type'] = 'application/json'
              request.headers['X-Correlation-Id'] = correlationId
              request.headers['X-Processing-Time'] = processingTime.toString()

# ==========================================
# APPLICATION SERVICE LAYER (USE CASES)
# ==========================================
- route:
    id: "customer-application-service"
    description: "Application Service - Business Use Cases Orchestration"
    from: 
      id: "customer-app-service"
      uri: "direct:customer-application-service"
      steps:
        # Business Logic Routing based on HTTP Method
        - choice:
            when:
              - simple: "${header.httpMethod} == 'GET'"
                steps:
                  - to: "direct:get-customer-use-case"
              - simple: "${header.httpMethod} == 'POST'"
                steps:
                  - to: "direct:create-customer-use-case"
              - simple: "${header.httpMethod} == 'PUT'"
                steps:
                  - to: "direct:update-customer-use-case"
              - simple: "${header.httpMethod} == 'DELETE'"
                steps:
                  - to: "direct:delete-customer-use-case"
            otherwise:
              steps:
                - script:
                    groovy: |
                      request.body = [
                        error: "Method not supported",
                        method: request.headers['httpMethod'],
                        timestamp: new Date().toString()
                      ]


# DOMAIN USE CASES (BUSINESS LOGIC)
# ==========================================
- route:
    id: "get-customer-use-case"
    description: "Domain Use Case - Get Customer"
    from: 
      uri: "direct:get-customer-use-case"
      steps:
        - script:
            groovy: |
              // Domain Logic: Parse customer ID from query parameters
              def query = request.headers['CamelHttpQuery']
              def customerId = null
              
              if (query?.contains('id=')) {
                customerId = query.split('id=')[1].split('&')[0]
              }
              
              log.info("üèõÔ∏è DOMAIN - Get Customer Use Case - ID: ${customerId}")
              
              // Business Rule: Validate customer ID
              if (!customerId || customerId.isEmpty()) {
                request.body = [
                  error: "Customer ID is required",
                  timestamp: new Date().toString()
                ]
                request.headers['businessError'] = true
              } else {
                request.headers['customerId'] = customerId
                request.headers['operation'] = 'GET'
              }
        
        # Call repository port only if no business error
        - choice:
            when:
              - simple: "${header.businessError} != 'true'"
                steps:
                  - to: "direct:customer-repository-port"

- route:
    id: "create-customer-use-case"
    description: "Domain Use Case - Create Customer"
    from: 
      uri: "direct:create-customer-use-case"
      steps:
        - script:
            groovy: |
              log.info("üèõÔ∏è DOMAIN - Create Customer Use Case")
              
              def customerData = request.body
              
              // Business Rules Validation
              def errors = []
              
              if (!customerData?.name || customerData.name.toString().trim().isEmpty()) {
                errors.add("Customer name is required")
              }
              
              if (!customerData?.email || !customerData.email.toString().contains('@')) {
                errors.add("Valid email is required")
              }
              
              // Business Rule: Name must be at least 2 characters
              if (customerData?.name && customerData.name.toString().length() < 2) {
                errors.add("Customer name must be at least 2 characters")
              }
              
              if (errors.size() > 0) {
                request.body = [
                  error: "Validation failed",
                  details: errors,
                  timestamp: new Date().toString()
                ]
                request.headers['businessError'] = true
              } else {
                // Generate domain entity
                def customer = [
                  id: UUID.randomUUID().toString(),
                  name: customerData.name,
                  email: customerData.email,
                  createdAt: new Date().toString(),
                  status: 'ACTIVE'
                ]
                
                request.body = customer
                request.headers['operation'] = 'CREATE'
                log.info("Created customer entity: ${customer}")
              }
        
        - choice:
            when:
              - simple: "${header.businessError} != 'true'"
                steps:
                  - to: "direct:customer-repository-port"

- route:
    id: "update-customer-use-case"
    description: "Domain Use Case - Update Customer"
    from: 
      uri: "direct:update-customer-use-case"
      steps:
        - script:
            groovy: |
              log.info("üèõÔ∏è DOMAIN - Update Customer Use Case")
              
              def customerData = request.body
              def query = request.headers['CamelHttpQuery']
              def customerId = null
              
              if (query?.contains('id=')) {
                customerId = query.split('id=')[1].split('&')[0]
              }
              
              // Business validation
              if (!customerId) {
                request.body = [error: "Customer ID is required for update"]
                request.headers['businessError'] = true
              } else {
                // Update timestamp (business rule)
                customerData.id = customerId
                customerData.updatedAt = new Date().toString()
                
                request.body = customerData
                request.headers['customerId'] = customerId
                request.headers['operation'] = 'UPDATE'
              }
        
        - choice:
            when:
              - simple: "${header.businessError} != 'true'"
                steps:
                  - to: "direct:customer-repository-port"

- route:
    id: "delete-customer-use-case"
    description: "Domain Use Case - Delete Customer"
    from: 
      uri: "direct:delete-customer-use-case"
      steps:
        - script:
            groovy: |
              log.info("üèõÔ∏è DOMAIN - Delete Customer Use Case")
              
              def query = request.headers['CamelHttpQuery']
              def customerId = null
              
              if (query?.contains('id=')) {
                customerId = query.split('id=')[1].split('&')[0]
              }
              
              if (!customerId) {
                request.body = [error: "Customer ID is required for deletion"]
                request.headers['businessError'] = true
              } else {
                request.headers['customerId'] = customerId
                request.headers['operation'] = 'DELETE'
              }
        
        - choice:
            when:
              - simple: "${header.businessError} != 'true'"
                steps:
                  - to: "direct:customer-repository-port"

# ==========================================
# REPOSITORY PORT (ABSTRACTION)
# ==========================================
- route:
    id: "customer-repository-port"
    description: "Port - Customer Repository Abstraction"
    from: 
      uri: "direct:customer-repository-port"
      steps:
        - script:
            groovy: |
              def repositoryType = context.resolvePropertyPlaceholders('{{customer.repository.type:memory}}')
              def operation = request.headers['operation']
              
              log.info("üîå PORT - Repository abstraction - Type: ${repositoryType}, Operation: ${operation}")
              
              // Route to appropriate adapter based on configuration
              request.headers['adapterEndpoint'] = "direct:customer-${repositoryType}-adapter"
        
        - recipientList:
            expression:
              simple: "${header.adapterEndpoint}"

# ==========================================
# SECONDARY ADAPTERS (DRIVEN ADAPTERS)
# ==========================================

# Memory Adapter (Default)
- route:
    id: "customer-memory-adapter"
    description: "Secondary Adapter - In-Memory Repository"
    from: 
      uri: "direct:customer-memory-adapter"
      steps:
        - script:
            groovy: |
              // Simulate in-memory storage using exchange properties
              def operation = request.headers['operation']
              def customerId = request.headers['customerId']
              
              log.info("üíæ MEMORY ADAPTER - Operation: ${operation}")
              
              // Get or create memory store
              def memoryStore = exchange.context.registry.lookupByName('customerMemoryStore')
              if (!memoryStore) {
                memoryStore = [:]
                exchange.context.registry.bind('customerMemoryStore', memoryStore)
              }
              
              switch(operation) {
                case 'GET':
                  def customer = memoryStore[customerId]
                  if (customer) {
                    request.body = customer
                  } else {
                    request.body = [error: "Customer not found", id: customerId]
                  }
                  break
                  
                case 'CREATE':
                  def customer = request.body
                  memoryStore[customer.id] = customer
                  request.body = [success: true, customer: customer]
                  break
                  
                case 'UPDATE':
                  def customer = request.body
                  if (memoryStore[customerId]) {
                    memoryStore[customerId] = customer
                    request.body = [success: true, customer: customer]
                  } else {
                    request.body = [error: "Customer not found for update", id: customerId]
                  }
                  break
                  
                case 'DELETE':
                  if (memoryStore[customerId]) {
                    def deleted = memoryStore.remove(customerId)
                    request.body = [success: true, deleted: deleted]
                  } else {
                    request.body = [error: "Customer not found for deletion", id: customerId]
                  }
                  break
              }
              
              log.info("Memory store size: ${memoryStore.size()}")

# File Adapter
- route:
    id: "customer-file-adapter"
    description: "Secondary Adapter - File-based Repository"
    from: 
      uri: "direct:customer-file-adapter"
      steps:
        - script:
            groovy: |
              import groovy.json.JsonSlurper
              import groovy.json.JsonBuilder
              
              def operation = request.headers['operation']
              def customerId = request.headers['customerId']
              def fileName = "customers.json"
              
              log.info("üìÅ FILE ADAPTER - Operation: ${operation}")
              
              // Read existing data
              def file = new File(fileName)
              def customers = [:]
              
              if (file.exists()) {
                try {
                  def jsonSlurper = new JsonSlurper()
                  customers = jsonSlurper.parse(file)
                } catch (Exception e) {
                  log.warn("Could not parse existing file: ${e.message}")
                }
              }
              
              switch(operation) {
                case 'GET':
                  def customer = customers[customerId]
                  if (customer) {
                    request.body = customer
                  } else {
                    request.body = [error: "Customer not found", id: customerId]
                  }
                  break
                  
                case 'CREATE':
                  def customer = request.body
                  customers[customer.id] = customer
                  // Write to file
                  def json = new JsonBuilder(customers)
                  file.text = json.toPrettyString()
                  request.body = [success: true, customer: customer]
                  break
                  
                case 'UPDATE':
                  def customer = request.body
                  if (customers[customerId]) {
                    customers[customerId] = customer
                    def json = new JsonBuilder(customers)
                    file.text = json.toPrettyString()
                    request.body = [success: true, customer: customer]
                  } else {
                    request.body = [error: "Customer not found for update", id: customerId]
                  }
                  break
                  
                case 'DELETE':
                  if (customers[customerId]) {
                    def deleted = customers.remove(customerId)
                    def json = new JsonBuilder(customers)
                    file.text = json.toPrettyString()
                    request.body = [success: true, deleted: deleted]
                  } else {
                    request.body = [error: "Customer not found for deletion", id: customerId]
                  }
                  break
              }

# Database Adapter (Simulated)
- route:
    id: "customer-database-adapter"
    description: "Secondary Adapter - Database Repository (Simulated)"
    from: 
      uri: "direct:customer-database-adapter"
      steps:
        - script:
            groovy: |
              def operation = request.headers['operation']
              def customerId = request.headers['customerId']
              
              log.info("üóÑÔ∏è DATABASE ADAPTER - Operation: ${operation}")
              
              // Simulate database operations with realistic delays
              Thread.sleep(50) // Simulate DB latency
              
              switch(operation) {
                case 'GET':
                  // Simulate database query
                  def customer = [
                    id: customerId,
                    name: "John Doe (from DB)",
                    email: "john@example.com",
                    createdAt: new Date().toString(),
                    status: "ACTIVE",
                    source: "database"
                  ]
                  request.body = customer
                  break
                  
                case 'CREATE':
                  def customer = request.body
                  customer.source = "database"
                  customer.dbId = Math.abs(new Random().nextInt())
                  request.body = [success: true, customer: customer, dbId: customer.dbId]
                  break
                  
                case 'UPDATE':
                  def customer = request.body
                  customer.source = "database"
                  customer.lastModified = new Date().toString()
                  request.body = [success: true, customer: customer]
                  break
                  
                case 'DELETE':
                  request.body = [
                    success: true, 
                    deleted: [id: customerId, deletedAt: new Date().toString()],
                    message: "Customer deleted from database"
                  ]
                  break
              }

# ==========================================
# NOTIFICATION PORT & ADAPTER (Optional)
# ==========================================
- route:
    id: "notification-port"
    description: "Port - Notification Service Abstraction"
    from: 
      uri: "direct:notification-port"
      steps:
        - script:
            groovy: |
              def notificationType = context.resolvePropertyPlaceholders('{{notification.type:log}}')
              log.info("üì¢ NOTIFICATION PORT - Type: ${notificationType}")
              
              request.headers['notificationEndpoint'] = "direct:notification-${notificationType}-adapter"
        
        - recipientList:
            expression:
              simple: "${header.notificationEndpoint}"

- route:
    id: "notification-log-adapter"
    description: "Secondary Adapter - Log Notification"
    from: 
      uri: "direct:notification-log-adapter"
      steps:
        - script:
            groovy: |
              def event = request.body
              log.info("üìß LOG NOTIFICATION: ${event}")

- route:
    id: "notification-email-adapter"
    description: "Secondary Adapter - Email Notification (Simulated)"
    from: 
      uri: "direct:notification-email-adapter"
      steps:
        - script:
            groovy: |
              def event = request.body
              log.info("üìß EMAIL NOTIFICATION (simulated): Sending email about ${event}")
              // In real implementation, this would integrate with email service

# ==========================================
# HEALTH CHECK & MONITORING
# ==========================================
- route:
    id: "health-check"
    description: "Health Check Endpoint"
    from: 
      uri: "jetty:http://0.0.0.0:8080/health"
      steps:
        - script:
            groovy: |
              def repositoryType = context.resolvePropertyPlaceholders('{{customer.repository.type:memory}}')
              def health = [
                status: "UP",
                timestamp: new Date().toString(),
                configuration: [
                  repositoryAdapter: repositoryType,
                  architecture: "hexagonal"
                ],
                components: [
                  "http-adapter": "UP",
                  "application-service": "UP",
                  "repository-port": "UP",
                  "${repositoryType}-adapter": "UP"
                ]
              ]
              
              request.body = health
        - setHeader:
            name: "Content-Type"
            constant: "application/json"
